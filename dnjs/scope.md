### 作用域是什么
变量存储在哪里？程序需要的时候如何找到这些变量呢？  <br>
以 var a = 2; 来看一下变量是如何赋值的：  <br>
1、遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果有，编译器就会忽略这个声明，继续进行编译，否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a   <br>
2、接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a=2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否有一个叫作a的变量，如果是，引擎就会使用这个变量；如果没有，引擎就会继续查找该变量 <br>
3、如果引擎最终找到了这个变量a，就会将2赋值给它；如果没有引擎就会举手示意并抛出一个异常。 <br>
> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后再运行时引擎会在作用域中查找该变量，如果能找到就会对其赋值。  <br>
> LHS：查找的目的是对变量进行赋值；RHS：查找的目的是获取该变量的值  <br>


如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出一个ReferenceError异常；但是，当引擎执行LHS查询时，如果再全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎。 <br>
但是在“严格模式”下，禁止自动或隐式地创建全局变量。 <br>
所以在严格模式下，LHS查询失败并不会创建并返回一个全局变量，引擎会抛出一个ReferenceError异常。 <br>
如果RHS查询找到了一个变量，但是当我们尝试对其进行不合理的操作（比如对一个非函数的值进行函数调用，或者引用null/undefined类型的值中的属性），那么引擎会抛出一个TypeError异常。
###### 作用域嵌套
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某一个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。


































