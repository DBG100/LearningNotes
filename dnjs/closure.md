### 作用域闭包
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。
```javascript
// 下面代码并不是闭包，但bar()对a的引用方法是词法作用域的查找规则是闭包很重要的一部分
function foo(){
  var a = 2;
  function bar(){
    console.log(a);   // 2
  }
  bar();
}
foo();
```
什么是闭包呢？
```javascript
function foo(){
  var a = 2;
  function bar(){
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz();            // 这就是闭包
// 函数bar()的词法作用域能够访问foo()内部作用域，然后我们将bar()函数本身当作一个值类型传递
// 在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz，实际上只是通过不同标识符引用了内部的函数bar()
// bar()在其定义的词法作用域以外的地方执行
```
> 在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑将其回收。  <br>
> 但是闭包就能阻止这种回收，但是事实上内部作用域依然存在，没有被回收。那是谁在使用这个内部作用域呢？  <br>
> 是bar()。因为bar()声明的位置，使得它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用。 <br>
###### bar()依然持有对该作用域的引用，这个引用就叫做“闭包”。 <br>


无论使用何种方式对函数类型的值进行传递，当函数在别处被调用的时候都可以观察到闭包：
```javascript
function foo(){
  var a = 2;
  function baz(){
    console.log(a);           // 2
  }
  bar(baz);
}
function bar(fn){
  fn();                // 这就是闭包（把内部函数baz传递给bar，当调用这个内部函数时（也就是fn），它涵盖的foo()内部作用域的闭包就可以观察到了）
}
```
传递函数也可以是间接的：
```javascript
var fn;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);           // 2
  }
  fn = baz;       // 将baz分配给全局变量
}
foo();
bar();                
```
> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。












