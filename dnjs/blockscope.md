### 词法作用域/函数作用域/块级作用域
#### 词法作用域
> 简单来说，词法作用域就是定义在词法阶段的作用域，也就是由我们在写代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持作用域不变。 <br>

作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中可以定义同名的标识符——“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域的查找始终从运行时所处的最内部作用域开始，逐级向外或者说是向上进行，直到遇见第一个匹配标识符为止。 <br>
> 全局变量会自动全局对象的属性，因此可以不直接通过全局对象的词法名称，而是间接通过对全局对象属性的引用来访问全局对象。这样可以访问那些被同名变量所遮蔽的全局变量。 <br>
但是非全局变量，如果被遮蔽了，就无法访问了。 <br>

无论函数在哪里被调用，无论函数如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 <br>
词法作用域查找只会查找一级标识符，比如a、b、c，如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。 <br>
> 编译的词法分析阶段基本能够知道全部标识符在哪里，以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 <br>

###### 欺骗词法作用域（修改词法作用域）——在运行期修改书写期的词法作用域
###### eval
javascript中的eval()函数可以接收一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中的这个位置。也就是说，可以在我们写的代码中用程序生成代码并运行，就好像代码是写在那个位置一样。 <br>
```javascript
function(str,a){
  eval(str);       // eval()调用"var b = 3;"，这段代码会被当作就在那里一样来处理
  // 由于eval()调用的代码声明了一个新的变量b，因此它对已经存在的foo()的词法作用域进行了修改（也就是说，这段代码实际上在foo()内部创建了一个变量b，并且遮蔽了外部（全局变量）作用域中的同名变量）
  console.log(a,b);
}
var b = 2;
foo("var b = 3;",1);        // 1,3
```
> 实际上，可以非常容易地根据程序逻辑动态地将字符串拼接在一起后再传进代码里面。eval()通常被用来执行动态创建的代码。 <br>


默认情况下，如果eval()中所执行的代码包含有一个或多个声明（无论是变量还是函数），都会对eval()所处的词法作用域进行修改。 <br>
在严格模式中，eval()在运行时有其自己的词法作用域，也就是说其中的声明无法修改所在的作用域。
> setTimeout()、setInterval()、new Function()也可以像eval()一样，参数可以是字符串，字符串的内容可以被解析为一段动态生成的函数代码，但是这种在程序中动态生成代码的使用场景，会非常消耗性能。 <br>


###### with
with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 <br>
with会将对象及其属性放进一个作用域并同时分配标识符。
```javascript
function foo(obj){
  // with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符
  with(obj){
    a = 2;   // LHS引用，将2赋值给a
  }
}
var o1 = {
  a:3;
};
var o2 = {
  b:3;
};
foo(o1);         // 将o1传递给foo()时，a=2赋值操作找到了o1.a并将2赋值给它
console.log(o1.a);     // 2
foo(o2);        // 将o2传递给foo()时，o2并没有a属性，因此不会创建这个属性
console.log(o2.a);     // undefined
console.log(a);        // 2——a被泄漏到全局作用域上了
```
> eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域。但是with声明实际上是根据我们传递给它的对象凭空创建了一个全新的词法作用域。 <br>

###### 性能
javascript引擎会在编译阶段进行数项性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 <br>
但是如果引擎在代码中发现了eval()/with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法再词法分析阶段明确指定eval()会接收到什么代码，这些代码如何对作用域进行修改，也无法知道传递给with用来创建新词法作用域的对象内容到底是什么。 <br>
如果出现了eval()/with，很肯能所有的优化都是无意义的。



















